Golang Benchmark

Peng Yi
peace0phmind@gmail.com

* prepare

To ensure benchmark test accurately, the CPU frequency scaling must be disabled.

Default on centos, this feature is closed. Or you can disable via:

	$ sudo bash
	# for i in /sys/devices/system/cpu/cpu[0-7]
	do
	    echo performance > $i/cpufreq/scaling_governor
	done
	#

* base operate

use those 3 test case

.code golang_benchmark/01_base_operate_test.go /Benchmark01NormalAdd/,/^}/

.code golang_benchmark/01_base_operate_test.go /Benchmark01Sleep1Microsecond/,/^}/ 

.code golang_benchmark/01_base_operate_test.go /Benchmark01Sleep1Second/

* base operate

run with

	go test -bench Benchmark01 -benchmem

got

	Benchmark01NormalAdd	2000000000	         0.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark01Sleep1Microsecond	2000000000	         0.59 ns/op	       0 B/op	       0 allocs/op
	Benchmark01Sleep1Second	       1	1000098061 ns/op	      64 B/op	       1 allocs/op

run with

	go test -bench Benchmark01 -benchmem -benchtime 5s

got

	Benchmark01NormalAdd	2000000000	         0.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark01Sleep1Microsecond	2000000000	         0.59 ns/op	       0 B/op	       0 allocs/op
	Benchmark01Sleep1Second	2000000000	         1.09 ns/op	       0 B/op	       0 allocs/op

* base operate

*Lessions*

- default -benchtime is 1s, if one test spend one more a second, benchmark will test one time only
- don't put large cost operate in benchmark test func. If need, put it in init func or const.

* function call

.code golang_benchmark/02_func_call_test.go /func add/,/^}/

.code golang_benchmark/02_func_call_test.go /type AddInt/,/^}/

.code golang_benchmark/02_func_call_test.go /type Add /,/type Add end/

* function call

run with

	go test -bench Benchmark02 -benchmem

got

	Benchmark02NormalAdd	2000000000	         0.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark02CallAddFunc	2000000000	         0.59 ns/op	       0 B/op	       0 allocs/op
	Benchmark02CallPackedIntAdd	2000000000	         1.77 ns/op	       0 B/op	       0 allocs/op
	Benchmark02CallIntStructAdd	2000000000	         1.77 ns/op	       0 B/op	       0 allocs/op
	Benchmark02CallStructAddFunc	2000000000	         0.59 ns/op	       0 B/op	       0 allocs/op

* function call

disassember the code:

	go tool 6g -S 02_func_call_test.go

line 32

.code golang_benchmark/02_func_call_test.go /Benchmark02NormalAdd/,/^}/

will be

	0x0012 00018 (02_func_call_test.go:32)  ADDQ    AX,CX
	0x0015 00021 (02_func_call_test.go:32)  NOP     ,

* function call

line 40

.code golang_benchmark/02_func_call_test.go /Benchmark02CallAddFunc/,/^}/

will be

	0x0012 00018 (02_func_call_test.go:40)  MOVQ    AX,BX
	0x0015 00021 (02_func_call_test.go:40)  ADDQ    CX,BX
	0x0018 00024 (02_func_call_test.go:40)  MOVQ    BX,CX	

* function call

line 48

.code golang_benchmark/02_func_call_test.go /Benchmark02CallPackedIntAdd/,/^}/

will be

	0x001c 00028 (02_func_call_test.go:48)  LEAQ    "".s+0(SP),BX
	0x0020 00032 (02_func_call_test.go:48)  NOP     ,
	0x0020 00032 (02_func_call_test.go:48)  MOVQ    (BX),DX
	0x0023 00035 (02_func_call_test.go:48)  NOP     ,
	0x0023 00035 (02_func_call_test.go:48)  MOVQ    AX,BP
	0x0026 00038 (02_func_call_test.go:48)  ADDQ    DX,BP
	0x0029 00041 (02_func_call_test.go:48)  MOVQ    BP,(BX)
	0x002c 00044 (02_func_call_test.go:48)  NOP     ,	

* function call

*Lessions*

- simple func call will be inline
- wrap base type to program object-oriented bring large cost

* array and slice iterator

i use three kind of iterator to iterator array and slice

.code golang_benchmark/03_iterator_test.go /var iarray/,/var islice/

.code golang_benchmark/03_iterator_test.go /Benchmark03ArrayForIterator/,/^}/

* array and slice iterator

.code golang_benchmark/03_iterator_test.go /Benchmark03ArrayRangeIterator/,/^}/

.code golang_benchmark/03_iterator_test.go /Benchmark03ArrayRangeValueIterator/,/^}/

* array and slice iterator

run array iterator

	go test -bench Benchmark03 -benchmem

got

	Benchmark03ArrayForIterator	200000000	         8.44 ns/op	       0 B/op	       0 allocs/op
	Benchmark03SliceForIterator	200000000	         8.93 ns/op	       0 B/op	       0 allocs/op
	Benchmark03ArrayRangeIterator	200000000	         8.40 ns/op	       0 B/op	       0 allocs/op
	Benchmark03SliceRangeIterator	200000000	         8.93 ns/op	       0 B/op	       0 allocs/op
	Benchmark03ArrayRangeValueIterator	100000000	        10.6 ns/op	       0 B/op	       0 allocs/op
	Benchmark03SliceRangeValueIterator	300000000	         5.81 ns/op	       0 B/op	       0 allocs/op

* array and slice iterator

- These three iterator cost is closed. But 'range value' method is faster then the others.
- Slice iterator is faster than array.

what's the different?

disassember code:

	go tool 6g -S 03_iterator_test.go


* interface pack and unpack

.code golang_benchmark/04_interface_pack_test.go /var constIntSlice/,/var packedIntSlice/

.code golang_benchmark/04_interface_pack_test.go /Benchmark04SetPackedIntSlice/,/^}/

.code golang_benchmark/04_interface_pack_test.go /Benchmark04GetPackedIntSlice/,/^}/

* interface pack and unpack

run

	go test -bench Benchmark04 -benchmem

got 

	Benchmark04SetIntSlice	100000000	        11.8 ns/op	       0 B/op	       0 allocs/op
	Benchmark04SetPackedIntSlice	 3000000	       488 ns/op	      80 B/op	      10 allocs/op
	Benchmark04GetIntSlice	200000000	         9.15 ns/op	       0 B/op	       0 allocs/op
	Benchmark04GetPackedIntSlice	20000000	       102 ns/op	       0 B/op	       0 allocs/op

*LESSONS*

- pack base type (int) bring additional memory allocs
- pack and unpack interface cost expensive

* memory use

run

	go test -bench Benchmark05 -benchmem

got

	Benchmark05UseInit	500000000	         3.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark05UseInitPointer	500000000	         3.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark05UseNew	500000000	         3.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark05AppendInit	 1000000	      1319 ns/op	     496 B/op	       5 allocs/op
	Benchmark05InitFixedArray	30000000	        45.5 ns/op	       0 B/op	       0 allocs/op
	Benchmark05MakeFixedSlice	30000000	        48.7 ns/op	       0 B/op	       0 allocs/op

disassember code:

	go tool 6g -S 05_new_make_test.go

* memory use

.code golang_benchmark/05_new_make_test.go /Benchmark05UseInitPointer/,/^}/

	0x0014 00020 (05_new_make_test.go:19)   LEAQ    "".autotmp_0002+0(SP),BX
	0x0018 00024 (05_new_make_test.go:19)   MOVQ    $0,(BX)
	0x001f 00031 (05_new_make_test.go:19)   MOVQ    $0,8(BX)
	0x0027 00039 (05_new_make_test.go:19)   LEAQ    "".autotmp_0002+0(SP),BX
	0x002b 00043 (05_new_make_test.go:19)   MOVQ    BX,CX
	0x002e 00046 (05_new_make_test.go:19)   CMPQ    BX,$0
	0x0032 00050 (05_new_make_test.go:19)   JEQ     $1,89
	0x0034 00052 (05_new_make_test.go:19)   LEAQ    (BX),BP
	0x0037 00055 (05_new_make_test.go:19)   LEAQ    go.string."world!"+0(SB),BX
	0x003e 00062 (05_new_make_test.go:19)   MOVQ    BP,DI
	0x0041 00065 (05_new_make_test.go:19)   MOVQ    BX,SI
	0x0044 00068 (05_new_make_test.go:19)   MOVSQ   ,
	0x0046 00070 (05_new_make_test.go:19)   MOVSQ   ,

	0x0059 00089 (05_new_make_test.go:19)   MOVL    AX,(BX)
	0x005b 00091 (05_new_make_test.go:19)   JMP     ,52

* memory use

.code golang_benchmark/05_new_make_test.go /Benchmark05UseNew/,/^}/

	0x0014 00020 (05_new_make_test.go:25)   LEAQ    "".autotmp_0005+0(SP),BX
	0x0018 00024 (05_new_make_test.go:25)   MOVQ    $0,(BX)
	0x001f 00031 (05_new_make_test.go:25)   MOVQ    $0,8(BX)
	0x0027 00039 (05_new_make_test.go:25)   LEAQ    "".autotmp_0005+0(SP),BX
	0x002b 00043 (05_new_make_test.go:25)   MOVQ    BX,CX
	0x002e 00046 (05_new_make_test.go:25)   NOP     ,
	0x002e 00046 (05_new_make_test.go:26)   CMPQ    BX,$0
	0x0032 00050 (05_new_make_test.go:26)   JEQ     $1,89
	0x0034 00052 (05_new_make_test.go:26)   LEAQ    (BX),BP
	0x0037 00055 (05_new_make_test.go:26)   LEAQ    go.string."world!"+0(SB),BX
	0x003e 00062 (05_new_make_test.go:26)   MOVQ    BP,DI
	0x0041 00065 (05_new_make_test.go:26)   MOVQ    BX,SI
	0x0044 00068 (05_new_make_test.go:26)   MOVSQ   ,
	0x0046 00070 (05_new_make_test.go:26)   MOVSQ   ,

	0x0059 00089 (05_new_make_test.go:26)   MOVL    AX,(BX)
	0x005b 00091 (05_new_make_test.go:26)   JMP     ,52

* memory use


.code golang_benchmark/05_new_make_test.go /Benchmark05MakeFixedSlice/,/^}/

* memory use

*Lessons*


* defer and panic

	Benchmark06NormalCall	2000000000	         0.30 ns/op	       0 B/op	       0 allocs/op
	Benchmark06NormalDoubleCall	1000000000	         2.07 ns/op	       0 B/op	       0 allocs/op
	Benchmark06Defer	20000000	        93.1 ns/op	       0 B/op	       0 allocs/op
	Benchmark06DoubleDefer	10000000	       195 ns/op	       0 B/op	       0 allocs/op
	Benchmark06CoverNoPanic	20000000	        96.0 ns/op	       0 B/op	       0 allocs/op
	Benchmark06ConstErrorPanic	10000000	       157 ns/op	       0 B/op	       0 allocs/op
	Benchmark06NewErrorPanic	10000000	       223 ns/op	      16 B/op	       1 allocs/op
	Benchmark06FmtErrorPanic	 5000000	       364 ns/op	      21 B/op	       2 allocs/op
	Benchmark06NumberPanic	10000000	       208 ns/op	       8 B/op	       1 allocs/op
	Benchmark06StringPanic	10000000	       222 ns/op	      16 B/op	       1 allocs/op

* buf reuse

* goroutine

* object pool

* reference

- http://blog.golang.org/profiling-go-programs