Golang Benchmark

Peng Yi
peace0phmind@gmail.com

* base operate

use those 3 test case

.code golang_benchmark/01_base_operate_test.go /BenchmarkBaseOperate/,/^}/

.code golang_benchmark/01_base_operate_test.go /BenchmarkBaseOperateSleep1Microsecond/,/^}/ 

.code golang_benchmark/01_base_operate_test.go /BenchmarkBaseOperateSleep1Second/

* base operate

run with

	go test -bench BenchmarkBaseOperate -benchmem

got

	BenchmarkBaseOperate	2000000000	         0.30 ns/op	       0 B/op	       0 allocs/op
	BenchmarkBaseOperateSleep1Microsecond	2000000000	         0.49 ns/op	       0 B/op	       0 allocs/op
	BenchmarkBaseOperateSleep1Second	       1	1004995127 ns/op	      64 B/op	       1 allocs/op

run with

	go test -bench BenchmarkBaseOperate -benchmem -benchtime 5s

got

	BenchmarkBaseOperate	2000000000	         0.30 ns/op	       0 B/op	       0 allocs/op
	BenchmarkBaseOperateSleep1Microsecond	2000000000	         0.49 ns/op	       0 B/op	       0 allocs/op
	BenchmarkBaseOperateSleep1Second	2000000000	         1.00 ns/op	       0 B/op	       0 allocs/op

* base operate

Lessions

- default -benchtime is 1s, if one test spend one more a second, benchmark will test one time only
- don't put large spend time operate in benchmark test, if need, put it on init or const.

* call func spend

.code golang_benchmark/01_base_operate.go /func add/,/^}/

.code golang_benchmark/01_base_operate.go /type AddInt/,/^}/

.code golang_benchmark/01_base_operate.go /type Add /,

* call func spend

run with

	go test -bench BenchmarkAdd -benchmem

got

	BenchmarkAddFuncCall	2000000000	         0.48 ns/op	       0 B/op	       0 allocs/op
	BenchmarkAddIntStructCall	2000000000	         1.79 ns/op	       0 B/op	       0 allocs/op
	BenchmarkAddStructCall	2000000000	         1.79 ns/op	       0 B/op	       0 allocs/op
	BenchmarkAddTwoStructCall	2000000000	         0.47 ns/op	       0 B/op	       0 allocs/op

* call func spend

disassember the code:

	go tool 6g -S 01_base_operate_test.go 01_base_operate.go

line 11

.code golang_benchmark/01_base_operate_test.go /BenchmarkBaseOperate/,/^}/

will be

	0x0012 00018 (01_base_operate_test.go:11)	ADDQ	AX,CX
	0x0015 00021 (01_base_operate_test.go:11)	NOP	,

* call func spend

line 37

.code golang_benchmark/01_base_operate_test.go /BenchmarkAddFuncCall/,/^}/

will be

	0x0012 00018 (01_base_operate_test.go:37)	MOVQ	AX,BX
	0x0015 00021 (01_base_operate_test.go:37)	ADDQ	CX,BX
	0x0018 00024 (01_base_operate_test.go:37)	MOVQ	BX,CX

* call func spend

line 45

.code golang_benchmark/01_base_operate_test.go /BenchmarkAddIntStructCall/,/^}/

will be

	0x001c 00028 (01_base_operate_test.go:45)	LEAQ	"".s+0(SP),BX
	0x0020 00032 (01_base_operate_test.go:45)	NOP	,
	0x0020 00032 (01_base_operate_test.go:45)	MOVQ	(BX),DX
	0x0023 00035 (01_base_operate_test.go:45)	NOP	,
	0x0023 00035 (01_base_operate_test.go:45)	MOVQ	AX,BP
	0x0026 00038 (01_base_operate_test.go:45)	ADDQ	DX,BP
	0x0029 00041 (01_base_operate_test.go:45)	MOVQ	BP,(BX)
	0x002c 00044 (01_base_operate_test.go:45)	NOP	,


* call func spend

Lessions

- simple func call will be inline
- wrap base type to program object-oriented bring large cost

* array and slice iterator

i use three kind of iterator to iterator array and slice

.code golang_benchmark/03_array_iterator_test.go /var iarray/,/var islice/

.code golang_benchmark/03_array_iterator_test.go /BenchmarkIteratorArray/,/^}/

* array and slice iterator

.code golang_benchmark/03_array_iterator_test.go /BenchmarkIteratorArrayRange/,/^}/

.code golang_benchmark/03_array_iterator_test.go /BenchmarkIteratorArrayRangeValue/,/^}/

* array and slice iterator

run array iterator

	go test -bench BenchmarkIterator -benchmem

got

	BenchmarkIteratorArrayFor	200000000	         8.24 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorSliceFor	300000000	         5.84 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorArrayRange	200000000	         8.14 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorSliceRange	300000000	         5.82 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorArrayRangeValue	200000000	         9.02 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorSliceRangeValue	300000000	         5.07 ns/op	       0 B/op	       0 allocs/op

what's the different?

disassember code:

	go tool 6g -S 03_array_iterator_test.go

* array and slice iterator

