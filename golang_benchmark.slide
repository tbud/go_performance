Golang Benchmark

Peng Yi
peace0phmind@gmail.com

* prepare

To ensure benchmark test accurately, the CPU frequency scaling must be disabled.

Default on centos, this feature is closed. Or you can disable via:

	$ sudo bash
	# for i in /sys/devices/system/cpu/cpu[0-7]
	do
	    echo performance > $i/cpufreq/scaling_governor
	done
	#

* base operate

use those 3 test case

.code golang_benchmark/01_base_operate_test.go /Benchmark01NormalAdd/,/^}/

.code golang_benchmark/01_base_operate_test.go /Benchmark01Sleep1Microsecond/,/^}/ 

.code golang_benchmark/01_base_operate_test.go /Benchmark01Sleep1Second/

* base operate

run with

	go test -bench Benchmark01 -benchmem

got

	Benchmark01NormalAdd	2000000000	         0.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark01Sleep1Microsecond	2000000000	         0.59 ns/op	       0 B/op	       0 allocs/op
	Benchmark01Sleep1Second	       1	1000098061 ns/op	      64 B/op	       1 allocs/op

run with

	go test -bench Benchmark01 -benchmem -benchtime 5s

got

	Benchmark01NormalAdd	2000000000	         0.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark01Sleep1Microsecond	2000000000	         0.59 ns/op	       0 B/op	       0 allocs/op
	Benchmark01Sleep1Second	2000000000	         1.09 ns/op	       0 B/op	       0 allocs/op

* base operate

Lessions

- default -benchtime is 1s, if one test spend one more a second, benchmark will test one time only
- don't put large cost operate in benchmark test func. If need, put it in init func or const.

* function call

.code golang_benchmark/02_func_call_test.go /func add/,/^}/

.code golang_benchmark/02_func_call_test.go /type AddInt/,/^}/

.code golang_benchmark/02_func_call_test.go /type Add /,/type Add end/

* function call

run with

	go test -bench Benchmark02 -benchmem

got

	Benchmark02NormalAdd	2000000000	         0.54 ns/op	       0 B/op	       0 allocs/op
	Benchmark02CallAddFunc	2000000000	         0.59 ns/op	       0 B/op	       0 allocs/op
	Benchmark02CallPackedIntAdd	2000000000	         1.77 ns/op	       0 B/op	       0 allocs/op
	Benchmark02CallIntStructAdd	2000000000	         1.77 ns/op	       0 B/op	       0 allocs/op
	Benchmark02CallStructAddFunc	2000000000	         0.59 ns/op	       0 B/op	       0 allocs/op

* function call

disassember the code:

	go tool 6g -S 02_func_call_test.go

line 32

.code golang_benchmark/02_func_call_test.go /Benchmark02NormalAdd/,/^}/

will be

	0x0012 00018 (02_func_call_test.go:32)  ADDQ    AX,CX
	0x0015 00021 (02_func_call_test.go:32)  NOP     ,

* function call

line 40

.code golang_benchmark/02_func_call_test.go /Benchmark02CallAddFunc/,/^}/

will be

	0x0012 00018 (02_func_call_test.go:40)  MOVQ    AX,BX
	0x0015 00021 (02_func_call_test.go:40)  ADDQ    CX,BX
	0x0018 00024 (02_func_call_test.go:40)  MOVQ    BX,CX	

* function call

line 48

.code golang_benchmark/01_base_operate_test.go /Benchmark02CallPackedIntAdd/,/^}/

will be

	0x001c 00028 (02_func_call_test.go:48)  LEAQ    "".s+0(SP),BX
	0x0020 00032 (02_func_call_test.go:48)  NOP     ,
	0x0020 00032 (02_func_call_test.go:48)  MOVQ    (BX),DX
	0x0023 00035 (02_func_call_test.go:48)  NOP     ,
	0x0023 00035 (02_func_call_test.go:48)  MOVQ    AX,BP
	0x0026 00038 (02_func_call_test.go:48)  ADDQ    DX,BP
	0x0029 00041 (02_func_call_test.go:48)  MOVQ    BP,(BX)
	0x002c 00044 (02_func_call_test.go:48)  NOP     ,	

* function call

Lessions

- simple func call will be inline
- wrap base type to program object-oriented bring large cost

* array and slice iterator

i use three kind of iterator to iterator array and slice

.code golang_benchmark/03_array_iterator_test.go /var iarray/,/var islice/

.code golang_benchmark/03_array_iterator_test.go /BenchmarkIteratorArray/,/^}/

* array and slice iterator

.code golang_benchmark/03_array_iterator_test.go /BenchmarkIteratorArrayRange/,/^}/

.code golang_benchmark/03_array_iterator_test.go /BenchmarkIteratorArrayRangeValue/,/^}/

* array and slice iterator

run array iterator

	go test -bench BenchmarkIterator -benchmem

got

	BenchmarkIteratorArrayFor	200000000	         8.84 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorSliceFor	200000000	         8.45 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorArrayRange	200000000	         8.96 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorSliceRange	200000000	         8.28 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorArrayRangeValue	200000000	         8.27 ns/op	       0 B/op	       0 allocs/op
	BenchmarkIteratorSliceRangeValue	200000000	         8.05 ns/op	       0 B/op	       0 allocs/op


* array and slice iterator

- These three iterator cost is closed. But 'range value' method is faster then the others.
- Slice iterator is faster than array.

what's the different?

disassember code:

	go tool 6g -S 03_array_iterator_test.go


* interface pack and unpack

.code golang_benchmark/04_interface_pack_test.go /var intUnpackMap/,/var intPackInterfaceMap/

.code golang_benchmark/04_interface_pack_test.go /BenchmarkInterfacePack/,/^}/

.code golang_benchmark/04_interface_pack_test.go /BenchmarkInterfaceUnPack/,/^}/

* interface pack and unpack

got 

	BenchmarkInterfaceIntPackBase	100000000	        11.8 ns/op	       0 B/op	       0 allocs/op
	BenchmarkInterfacePack	 3000000	       494 ns/op	      80 B/op	      10 allocs/op
	BenchmarkInterfaceIntUnpackBase	200000000	         9.15 ns/op	       0 B/op	       0 allocs/op
	BenchmarkInterfaceUnPack	20000000	       100 ns/op	       0 B/op	       0 allocs/op

*LESSONS*

- pack and unpack interface to base type cost expensive

* new and make




* defer and panic

	Benchmark06NormalCall	2000000000	         0.30 ns/op	       0 B/op	       0 allocs/op
	Benchmark06NormalDoubleCall	1000000000	         2.07 ns/op	       0 B/op	       0 allocs/op
	Benchmark06Defer	20000000	        93.1 ns/op	       0 B/op	       0 allocs/op
	Benchmark06DoubleDefer	10000000	       195 ns/op	       0 B/op	       0 allocs/op
	Benchmark06CoverNoPanic	20000000	        96.0 ns/op	       0 B/op	       0 allocs/op
	Benchmark06ConstErrorPanic	10000000	       157 ns/op	       0 B/op	       0 allocs/op
	Benchmark06NewErrorPanic	10000000	       223 ns/op	      16 B/op	       1 allocs/op
	Benchmark06FmtErrorPanic	 5000000	       364 ns/op	      21 B/op	       2 allocs/op
	Benchmark06NumberPanic	10000000	       208 ns/op	       8 B/op	       1 allocs/op
	Benchmark06StringPanic	10000000	       222 ns/op	      16 B/op	       1 allocs/op

* buf reuse

* goroutine

* object pool

* reference

- http://blog.golang.org/profiling-go-programs